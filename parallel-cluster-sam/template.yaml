AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  Create a new parallel cluster


Parameters:
  ################## policy parameters ##################
  Region:
    Description: When set to a given region name (e.g. eu-west-1), the API can control resources in that region only. Set to '*' to control all regions.
    Type: String
    Default: '*'


  PermissionsBoundaryPolicy:
    Description: |
      ARN of a IAM policy to use as PermissionsBoundary for all IAM resources created by ParallelCluster API.
      When specified, IAM permissions assumed by the API are conditionally restricted to the usage of the given PermissionsBoundary
    Type: String
    Default: ''


  ################## cluster parameters ##################
  ScriptUrl:
    Description: URL to the script to run on the head node. /scripts/cluster-config.sh
    Type: String


  FirstAZPrivateSubnetId:
    Description: The ID of the first private subnet in the first availability zone.
    Type: AWS::EC2::Subnet::Id


  KeyName:
    Description: KeyPair to login to the head node
    Type: AWS::EC2::KeyPair::KeyName
    AllowedPattern: ".+"  # Required

  HeadNodeInstanceType:
    Description: Headnode instance type
    Type: String
    AllowedValues: [m6i.xlarge, m6i.2xlarge, m7i.xlarge, m7i.2xlarge]

  ComputeNodeSubnets:
    Description: List of subnets for compute nodes, spread across different AZs
    Type: List<AWS::EC2::Subnet::Id>

  DatabaseClientSecGroup:
    Type: AWS::EC2::SecurityGroup::Id

  HeadNodeSecGroup:
    Type: AWS::EC2::SecurityGroup::Id

  ComputeNodeSecGroup:
    Type: AWS::EC2::SecurityGroup::Id

  VizBackendSecGroup:
    Type: AWS::EC2::SecurityGroup::Id

  DatabaseUri:
    Type: String
    Default: slurm-accounting-cluster.cluster-c2oelv7l4dpl.us-east-1.rds.amazonaws.com
    Description: Uri pointing to database cluster

  DatabaseAdmin:
    Type: String
    Description: Admin username
    Default: clusteradmin

  DatabasePasswordSecretArn:
    Type: String
    Description: Amin password Secret ARN
    NoEcho: true

  ADDomain:
    Type: String
    Description: Active directory domain
    Default: tandemai.com

  ADAddr:
    Type: String
    Description: Active directory address
    Default: ldap://company.com

  ADPasswordSecretArn:
    Type: String
    Description: Active directory secret ARN
    NoEcho: true

  ADReadonlyUser:
    Type: String
    Description: read only user from active directory
    Default: CN=ReadOnlyUser

  EFSFileSystemId:
    Type: String
    Description: shared file system - efs - for software. Empty will mount nothing

  HeadNodeRootVolumeSize:
    Type: Number
    Description: Size of root volume in headnode
    Default: 200

  HeadNodeRootVolumeEncrypted:
    Type: String
    Description: whether head node volume is encrpted
    Default: true
    AllowedValues: [true, false]

  ComputeNodeRootVolumeType:
    Type: String
    Description: type of root volume
    Default: gp3
    AllowedValues: [io1, io2, gp3]

  ComputeNodeRootVolumeSize:
    Type: Number
    Description: Size of root volume in headnode
    Default: 150

  ComputeNodeRootVolumeEncrypted:
    Type: String
    Description: whether head node volume is encrpted
    Default: true
    AllowedValues: [true, false]

  HeadNodeRootVolumeType:
    Type: String
    Description: type of root volume
    Default: gp3
    AllowedValues: [io1, io2, gp3]

  CpuQueueNodeType:
    Type: String
    Description: Node type of CPU queue
    Default: c6i.2xlarge
    AllowedValues: [c6i.2xlarge, c6i.4xlarge, c6i.8xlarge, c6i.16xlarge, c6i.metal, c7i.2xlarge, c7i.4xlarge, c7i.8xlarge, c7i.16xlarge, c7i.48xlarge]

  CpuQueueNodesMax:
    Type: Number
    Description: Max number of nodes
    Default: 10

  LightGpuQueueNodeType:
    Type: String
    Description: Node type of light GPU queue
    Default: g4dn.xlarge
    AllowedValues: [g4dn.xlarge, g4dn.2xlarge, g4dn.4xlarge]

  LightGpuQueueNodesMax:
    Type: Number
    Description: Max number of nodes
    Default: 10

  DebugQueueGPUNodeType:
    Type: String
    Description: Node type of light GPU queue
    Default: g4dn.xlarge
    AllowedValues: [g4dn.xlarge]

  DebugQueueGPUNodeMax:
    Type: Number
    Description: Maximum number of GPU nodes in debug queue
    Default: 2

  DebugQueueCPUNodeType:
    Type: String
    Description: Node type of light GPU queue
    Default: c6i.xlarge
    AllowedValues: [c6i.xlarge, c6i.2xlarge, c6i.4xlarge, c6i.8xlarge, c7i.xlarge, c7i.2xlarge, c7i.4xlarge, c7i.8xlarge]

  DebugQueueCPUNodesMax:
    Type: Number
    Description: Max number of nodes for debug in the cpu section
    Default: 5

  ProjectQueueCpuNodeType:
    Type: String
    Description: Node type of CPU queue
    Default: c6i.2xlarge
    AllowedValues: [c6i.2xlarge, c6i.4xlarge, c6i.8xlarge, c6i.16xlarge, c6i.metal, c7i.2xlarge, c7i.4xlarge, c7i.8xlarge, c7i.16xlarge, c7i.48xlarge]

  ProjectQueueCpuNodesMax:
    Type: Number
    Description: Max number of nodes
    Default: 10

  ProjectQueueGpuNodeType:
    Type: String
    Description: Node type of GPU queue - be careful with p4d.24xlarge
    Default: g4dn.12xlarge
    AllowedValues: [g4dn.xlarge, g4dn.12xlarge, g4dn.metal, p3.2xlarge, p3.8xlarge, p3.16xlarge, p4d.24xlarge, p5.48xlarge, g5.xlarge, g5.12xlarge, g5.48xlarge]

  ProjectQueueGpuNodesMax:
    Type: Number
    Description: Max number of nodes
    Default: 10

  ClusterName:
    Type: String
    Default: "tcluster"
    Description: "Name of the parallel cluster"
    AllowedPattern: ".+"
    MinLength: 2
    MaxLength: 20

  CustomAmiId:
    Description: Custom AMI of the image
    Type: 'AWS::EC2::Image::Id'

Conditions:
  IsMultiRegion: !Equals [!Ref Region, '*']
  EnablePermissionsBoundary: !Not [!Equals [!Ref PermissionsBoundaryPolicy, '']]
  InIsolatedRegion: !Or
    - !Equals [!Ref AWS::Partition, 'aws-iso']
    - !Equals [!Ref AWS::Partition, 'aws-iso-b']

Resources:
  ###########################################################################################
  ## Policies ###############################################################################
  DefaultParallelClusterIamAdminPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Roles:
        - !Ref ParallelClusterLambdaRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - iam:CreateServiceLinkedRole
              - iam:DeleteRole
              - iam:TagRole
            Resource:
              - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*
            Effect: Allow
            Sid: IamRole
          - Action:
              - iam:CreateRole
            Resource:
              - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*
            Effect: Allow
            Condition: !If
              - EnablePermissionsBoundary
              - StringEquals:
                  iam:PermissionsBoundary:
                    - !Ref PermissionsBoundaryPolicy
              - !Ref AWS::NoValue
            Sid: IamCreateRole
          - Action:
              - iam:PutRolePolicy
              - iam:DeleteRolePolicy
            Resource: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*
            Effect: Allow
            Sid: IamInlinePolicy
            Condition: !If
              - EnablePermissionsBoundary
              - StringEquals:
                  iam:PermissionsBoundary:
                    - !Ref PermissionsBoundaryPolicy
              - !Ref AWS::NoValue
          - Action:
              - iam:AttachRolePolicy
              - iam:DetachRolePolicy
            Resource: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*
            Condition:
              ArnLike:
                iam:PolicyARN:
                  - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/parallelcluster*
                  - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/parallelcluster/*
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/CloudWatchAgentServerPolicy
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSBatchFullAccess
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonS3ReadOnlyAccess
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSBatchServiceRole
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonEC2SpotFleetTaggingRole
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/EC2InstanceProfileForImageBuilder
                  - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
              StringEquals: !If
                - EnablePermissionsBoundary
                - iam:PermissionsBoundary:
                    - !Ref PermissionsBoundaryPolicy
                - !Ref AWS::NoValue
            Effect: Allow
            Sid: IamPolicy


  ParallelClusterLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns:
        # Required for Lambda logging and XRay
        - !If
          - InIsolatedRegion
          - !Ref AWS::NoValue
          - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSXRayDaemonWriteAccess
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        # Required to run ParallelCluster functionalities
        - !Ref ParallelClusterClusterPolicy
        - !Ref ParallelClusterListImagesManagedPolicy
        - !Ref ParallelClusterDescribeImageManagedPolicy
        - !Ref ParallelClusterLogRetrievalPolicy

  ### CLUSTER ACTIONS POLICIES


  ParallelClusterClusterPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - ec2:Describe*
            Resource: '*'
            Effect: Allow
            Condition: !If
              - IsMultiRegion
              - !Ref AWS::NoValue
              - StringEquals:
                  aws:RequestedRegion:
                    - !Ref Region
            Sid: EC2Read
          - Action:
              - ec2:AllocateAddress
              - ec2:AssociateAddress
              - ec2:AttachNetworkInterface
              - ec2:AuthorizeSecurityGroupEgress
              - ec2:AuthorizeSecurityGroupIngress
              - ec2:CreateFleet
              - ec2:CreateLaunchTemplate
              - ec2:CreateLaunchTemplateVersion
              - ec2:CreateNetworkInterface
              - ec2:CreatePlacementGroup
              - ec2:CreateSecurityGroup
              - ec2:CreateSnapshot
              - ec2:CreateTags
              - ec2:CreateVolume
              - ec2:DeleteLaunchTemplate
              - ec2:DeleteNetworkInterface
              - ec2:DeletePlacementGroup
              - ec2:DeleteSecurityGroup
              - ec2:DeleteVolume
              - ec2:DisassociateAddress
              - ec2:ModifyLaunchTemplate
              - ec2:ModifyNetworkInterfaceAttribute
              - ec2:ModifyVolume
              - ec2:ModifyVolumeAttribute
              - ec2:ReleaseAddress
              - ec2:RevokeSecurityGroupEgress
              - ec2:RevokeSecurityGroupIngress
              - ec2:RunInstances
              - ec2:TerminateInstances
            Resource: '*'
            Effect: Allow
            Condition: !If
              - IsMultiRegion
              - !Ref AWS::NoValue
              - StringEquals:
                  aws:RequestedRegion:
                    - !Ref Region
            Sid: EC2Write
          - Action:
              - dynamodb:DescribeTable
              - dynamodb:ListTagsOfResource
              - dynamodb:CreateTable
              - dynamodb:DeleteTable
              - dynamodb:GetItem
              - dynamodb:PutItem
              - dynamodb:UpdateItem
              - dynamodb:Query
              - dynamodb:TagResource
            Resource: !Sub arn:${AWS::Partition}:dynamodb:${Region}:${AWS::AccountId}:table/parallelcluster-*
            Effect: Allow
            Sid: DynamoDB
          - Action:
              - route53:ChangeResourceRecordSets
              - route53:ChangeTagsForResource
              - route53:CreateHostedZone
              - route53:DeleteHostedZone
              - route53:GetChange
              - route53:GetHostedZone
              - route53:ListResourceRecordSets
              - route53:ListQueryLoggingConfigs
            Resource: '*'
            Effect: Allow
            Sid: Route53HostedZones
          - Action:
              - cloudformation:CreateStack
            Resource: !Sub
              - arn:*:cloudformation:${RequestedRegion}:${AWS::AccountId}:stack/*
              - RequestedRegion: !If [IsMultiRegion, '*', !Ref Region]
            Effect: Allow
            Condition:
              ForAnyValue:StringEquals:
                aws:TagKeys: ["parallelcluster:cluster-name"]
            Sid: CloudFormationCreate
          - Action:
              - cloudformation:UpdateStack
            Resource: !Sub
              - arn:*:cloudformation:${RequestedRegion}:${AWS::AccountId}:stack/*
              - RequestedRegion: !If [IsMultiRegion, '*', !Ref Region]
            Effect: Allow
            Condition:
              ForAnyValue:StringLike:
                aws:ResourceTag/parallelcluster:cluster-name: "*"
            Sid: CloudFormationUpdate
          - Action:
              - cloudformation:DeleteStack
              - cloudformation:DescribeStacks
              - cloudformation:DescribeStackEvents
              - cloudformation:DescribeStackResources
              - cloudformation:GetTemplate
              - cloudformation:ListStacks
            Resource: !Sub
              - arn:*:cloudformation:${RequestedRegion}:${AWS::AccountId}:stack/*
              - RequestedRegion: !If [IsMultiRegion, '*', !Ref Region]
            Effect: Allow
            Sid: CloudFormationReadAndDelete
          - Action:
              - cloudwatch:PutDashboard
              - cloudwatch:ListDashboards
              - cloudwatch:DeleteDashboards
              - cloudwatch:GetDashboard
              - cloudwatch:PutMetricAlarm
              - cloudwatch:DeleteAlarms
              - cloudwatch:DescribeAlarms
            Resource: '*'
            Effect: Allow
            Condition: !If
              - IsMultiRegion
              - !Ref AWS::NoValue
              - StringEquals:
                  aws:RequestedRegion:
                    - !Ref Region
            Sid: CloudWatch
          - Action:
              - iam:GetRole
              - iam:GetRolePolicy
              - iam:GetPolicy
              - iam:SimulatePrincipalPolicy
              - iam:GetInstanceProfile
            Resource:
              - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/*
              - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/*
              - !Sub arn:${AWS::Partition}:iam::aws:policy/*
              - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/*
            Effect: Allow
            Sid: IamRead
          - Action:
              - iam:CreateInstanceProfile
              - iam:DeleteInstanceProfile
              - iam:AddRoleToInstanceProfile
              - iam:RemoveRoleFromInstanceProfile
            Resource:
              - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/parallelcluster/*
            Effect: Allow
            Sid: IamInstanceProfile
          - Action:
              - iam:PassRole
            Resource:
              - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/parallelcluster/*
            Effect: Allow
            Condition:
              StringEqualsIfExists:
                iam:PassedToService:
                  - lambda.amazonaws.com
                  - ec2.amazonaws.com
                  - ec2.amazonaws.com.cn
                  - spotfleet.amazonaws.com
            Sid: IamPassRole
          - Action:
              - iam:CreateServiceLinkedRole
              - iam:DeleteServiceLinkedRole
            Resource: '*'
            Effect: Allow
            Condition:
              StringEquals:
                iam:AWSServiceName:
                  - fsx.amazonaws.com
                  - s3.data-source.lustre.fsx.amazonaws.com
          - Action:
              - lambda:CreateFunction
              - lambda:TagResource
              - lambda:DeleteFunction
              - lambda:GetFunctionConfiguration
              - lambda:GetFunction
              - lambda:InvokeFunction
              - lambda:AddPermission
              - lambda:RemovePermission
              - lambda:UpdateFunctionConfiguration
              - lambda:ListTags
              - lambda:UntagResource
            Resource:
              - !Sub arn:${AWS::Partition}:lambda:${Region}:${AWS::AccountId}:function:parallelcluster-*
              - !Sub arn:${AWS::Partition}:lambda:${Region}:${AWS::AccountId}:function:pcluster-*
            Effect: Allow
            Sid: Lambda
          - Action:
              - s3:*
            Resource:
              - !Sub arn:${AWS::Partition}:s3:::parallelcluster-*
              - !Sub arn:${AWS::Partition}:s3:::aws-parallelcluster-*
            Effect: Allow
            Condition: !If
              - IsMultiRegion
              - !Ref AWS::NoValue
              - StringEquals:
                  aws:RequestedRegion:
                    - !Ref Region
            Sid: S3ResourcesBucket
          - Action:
              - s3:Get*
              - s3:List*
            Resource: !Sub arn:${AWS::Partition}:s3:::${Region}-aws-parallelcluster*
            Effect: Allow
            Condition: !If
              - IsMultiRegion
              - !Ref AWS::NoValue
              - StringEquals:
                  aws:RequestedRegion:
                    - !Ref Region
            Sid: S3ParallelClusterReadOnly
          - Action:
              - fsx:*
            Resource:
              - !Sub arn:${AWS::Partition}:fsx:${Region}:${AWS::AccountId}:*
            Effect: Allow
            Sid: FSx
          - Action:
              - elasticfilesystem:*
            Resource:
              - !Sub arn:${AWS::Partition}:elasticfilesystem:${Region}:${AWS::AccountId}:*
            Effect: Allow
            Sid: EFS
          - Action:
              - logs:DeleteLogGroup
              - logs:PutRetentionPolicy
              - logs:DescribeLogGroups
              - logs:CreateLogGroup
              - logs:TagResource
              - logs:UntagResource
              - logs:DescribeMetricFilters
              - logs:PutMetricFilter
              - logs:deleteMetricFilter
            Resource: '*'
            Effect: Allow
            Condition: !If
              - IsMultiRegion
              - !Ref AWS::NoValue
              - StringEquals:
                  aws:RequestedRegion:
                    - !Ref Region
            Sid: CloudWatchLogs
          - Action:
              - resource-groups:ListGroupResources
              - resource-groups:GetGroupConfiguration
            Resource: '*'
            Effect: Allow
            Sid: ResourceGroupRead


  # ### IMAGE ACTIONS POLICIES

  ParallelClusterListImagesManagedPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Managed policy to execute pcluster list-images command
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: EC2
            Effect: Allow
            Action:
              - ec2:DescribeImages
            Resource: '*'
          - Sid: CloudFormation
            Effect: Allow
            Action:
              - cloudformation:DescribeStacks
            Resource:
              - '*'

  ParallelClusterDescribeImageManagedPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Managed policy to execute pcluster describe-image command
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: EC2
            Effect: Allow
            Action:
              - ec2:DescribeImages
            Resource: '*'
          - Sid: CloudFormation
            Effect: Allow
            Action:
              - cloudformation:DescribeStacks
            Resource:
              - !Sub 'arn:${AWS::Partition}:cloudformation:${Region}:${AWS::AccountId}:stack/*'

  ### LOG COMMANDS

  ParallelClusterLogRetrievalPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Policies needed to retrieve cluster and images logs
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
            - logs:DescribeLogGroups
            - logs:FilterLogEvents
            - logs:GetLogEvents
            - logs:CreateExportTask
            - logs:DescribeLogStreams
            - logs:DescribeExportTasks
            Resource: '*'
            Effect: Allow
            Condition: !If
              - IsMultiRegion
              - !Ref AWS::NoValue
              - StringEquals:
                  aws:RequestedRegion:
                    - !Ref Region

  ###########################################################################################
  ## Cluster ###############################################################################
  PclusterCfnFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      RetentionInDays: 90
      LogGroupName: !Sub /aws/lambda/${PclusterCfnFunction}

  EventsPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: EventsPolicy
            Effect: Allow
            Action:
              - events:PutRule
              - events:DeleteRule
              - events:PutTargets
              - events:RemoveTargets
            Resource: !Sub arn:${AWS::Partition}:events:${AWS::Region}:${AWS::AccountId}:rule/*
  S3Policy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: S3Policy
            Effect: Allow
            Action:
              - s3:*Object
              - s3:ListBucket
              - s3:ListBucketVersions
            Resource:
              - !Sub arn:${AWS::Partition}:s3:::${PclusterCustomResourceBucket}/*
              - !Sub arn:${AWS::Partition}:s3:::${PclusterCustomResourceBucket}

  PclusterCustomResourceBucket:
    Type: AWS::S3::Bucket

  ###########################################################################################
  ## lambda itself ##########################################################################

  PclusterLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns: !Split
        - ","
        - !Sub
          - ${LambdaExecutionPolicy},${ClusterPolicy},${DefaultAdminPolicy},${EventsPolicy},${S3Policy}
          - { LambdaExecutionPolicy: !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
              ClusterPolicy: !Ref ParallelClusterClusterPolicy ,
              DefaultAdminPolicy: !Ref DefaultParallelClusterIamAdminPolicy,
              EventsPolicy: !Ref EventsPolicy,
              S3Policy: !Ref S3Policy }

  PclusterLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      # LayerName: !Sub
      #   - PCLayer-${StackIdSuffix}
      #   - { StackIdSuffix: !Select [2, !Split ['/', !Ref 'AWS::StackId']] }
      Description: Library which contains aws-parallelcluster python package and dependencies
      Content:
        S3Bucket: !Sub "${AWS::Region}-aws-parallelcluster"
        S3Key: "parallelcluster/3.6.1/layers/aws-parallelcluster/lambda-layer.zip"
      CompatibleRuntimes:
        - python3.9

  PclusterCfnFunction:
    Type: AWS::Lambda::Function
    Properties:
      Tags:
        - Key: "parallelcluster:version"
          Value: "3.6.1"
        - Key: "parallelcluster:custom_resource"
          Value: "cluster"
      # FunctionName: !Sub
      #   - pcluster-cfn-${StackIdSuffix}
      #   - { StackIdSuffix: !Select [2, !Split ['/', !Ref 'AWS::StackId']] }
      TracingConfig:
        Mode: Active
      MemorySize: 2048
      Timeout: 60
      Handler: index.handler
      Runtime: python3.9
      Role: !GetAtt PclusterLambdaRole.Arn
      Layers:
        - !Ref PclusterLayer
      Code:
        ZipFile: !Sub |
          import boto3
          import cfnresponse
          import datetime
          import json
          import logging
          import os
          import random
          import re
          import string
          import sys
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          import pcluster.api.controllers.cluster_operations_controller
          import pcluster.api.errors
          import pcluster.utils
          from pcluster.api import encoder
          from pcluster.cli.exceptions import APIOperationException, ParameterException
          from pcluster.api.errors import exception_message, NotFoundException
          import pcluster.lib as pc

          crhelper_path = "/opt/python/pcluster/resources/custom_resources/custom_resources_code"
          sys.path.insert(0, crhelper_path)
          from crhelper import CfnResource
          helper = CfnResource()

          def drop_keys(_dict, keys):
              return {k: v for k, v in _dict.items() if k not in keys}

          def flatten(obj, ret={}, path=""):
              """flatten a nested map using dot-notation for keys."""
              if isinstance(obj, list):  # convert list to dictionary for flattening
                  return flatten({str(i): v for i, v in enumerate(obj)}, ret, path)
              for k, v in obj.items():
                  if isinstance(v, (dict, list)):  # recurse on complex objects
                      flatten(v, ret, f"{path}{k}.")
                  else:  # otherwise add with prefix
                      ret[path + str(k)] = v
              return ret

          def update_response(data):
              logger.info(data)
              # Avoid limit on response object size, user has provided these, so drop them in the response
              extra_keys = {"clusterConfiguration", "scheduler", "tags"}
              # create / delete responses have cluster information nested in "cluster" key,
              # flatten that portion while keeping other keys to propagate warnings.
              if "cluster" in data:
                  helper.Data.update(flatten(drop_keys(data["cluster"], extra_keys)))

                  validation_messages = json.dumps(data.get("validationMessages", []))
                  validation_messages = "TRUNCATED:" + validation_messages[:2048] if len(validation_messages) > 2048 else validation_messages
                  helper.Data["validationMessages"] = validation_messages
              else:  # without "cluster" in the keys, this is a cluster object.
                  helper.Data.update(flatten(drop_keys(data, extra_keys)))

          def serialize(val):
              return utils.to_iso_timestr(val) if isinstance(val, datetime.date) else val

          def get_stack_tags(stack_name, overrides):
              cfn = boto3.client('cloudformation')
              stack_tags = cfn.describe_stacks(StackName=stack_name)["Stacks"][0].get("Tags", [])
              return list(filter(lambda t: not (t["Key"].startswith("aws:") or t["Key"] in overrides), stack_tags))

          def create_or_update(event):
              properties = event["ResourceProperties"]
              full_event = json.loads(boto3.client("s3").get_object(Bucket="${PclusterCustomResourceBucket}",Key=properties.get("ClusterName")+"/event.json")["Body"].read())
              cluster_configuration = full_event["ResourceProperties"]["ClusterConfiguration"]
              request_type = event["RequestType"].upper()
              helper.Data["validationMessages"] = "[]"  # default value

              if properties.get("DeletionPolicy", "Delete") not in {"Retain", "Delete"}:
                  raise ValueError("DeletionPolicy must be one of [\"Retain\", \"Delete\"].")
              if request_type == "CREATE" and "ClusterName" not in properties:
                  raise ValueError("Couldn't find a ClusterName in the properties.")
              elif request_type == "UPDATE" and event["PhysicalResourceId"] != properties.get("ClusterName"):
                  raise ValueError("Cannot update the ClusterName in the properties.")

              cluster_name = properties["ClusterName"]
              logger.info(f"{event['RequestType'].upper()}: {cluster_name}")
              physical_resource_id = cluster_name

              try:
                  meta_keys = {"ServiceToken", "DeletionPolicy"}
                  kwargs = {**{pcluster.utils.to_snake_case(k): serialize(v) for k, v in drop_keys(properties, meta_keys).items()}, "wait": False}
                  kwargs["cluster_configuration"] = cluster_configuration
                  resource_tags = [{"Key": "parallelcluster:custom_resource", "Value": "cluster"}]
                  config_tags = cluster_configuration.get("Tags", [])
                  stack_tags = get_stack_tags(event['StackId'], {t["Key"] for t in config_tags})
                  kwargs["cluster_configuration"]["Tags"] = stack_tags + config_tags + resource_tags
                  func = {"CREATE": pc.create_cluster, "UPDATE": pc.update_cluster}[request_type]
                  update_response(func(**kwargs))
              except (APIOperationException, ParameterException, TypeError)  as e:
                  logger.info(str(e))
                  raise ValueError(str(e))
              except Exception as e:
                  message = pcluster.api.errors.exception_message(e)
                  # StatusReason is truncated, so skip changeset in output, still logged below
                  block_list = {"change_set"}
                  message_data = drop_keys(message.to_dict(), block_list)
                  logger.info(message_data)

                  # sort more critical errors last
                  if "configuration_validation_errors" in message_data and message_data["configuration_validation_errors"]:
                      order = {k: i for i, k in enumerate(["INFO", "WARNING", "ERROR"])}
                      message_data["configuration_validation_errors"].sort(key=lambda e: order[e["level"]])

                  str_msg = encoder.JSONEncoder().encode(message_data)
                  if not re.search(r"No changes found", str_msg):
                      logger.info(encoder.JSONEncoder().encode(message))
                      raise ValueError(str_msg)
                  logger.info(f"No changes found to update: {cluster_name}")

              return physical_resource_id

          @helper.create
          def create(event, context):
              return create_or_update(event)

          @helper.update
          def update(event, context):
              return create_or_update(event)

          @helper.delete
          def delete(event, context):
              properties = event["ResourceProperties"]
              cluster_name = properties.get("ClusterName")

              boto3.resource('s3').Bucket("${PclusterCustomResourceBucket}").objects.filter(Prefix=f"{cluster_name}/").delete()

              deletion_policy = properties.get("DeletionPolicy", "Delete")
              if deletion_policy not in {"Retain", "Delete"}:
                  raise ValueError("DeleetionPolicy must be one of [\"Retain\", \"Delete\"].")
              if deletion_policy == "Retain":
                  return cluster_name

              logger.info(f"Deleting: {cluster_name}")
              try:
                  update_response(pc.delete_cluster(cluster_name=cluster_name))
              except (ParameterException, NotFoundException): # cluster deleted or invalid name -- ignore here.
                  pass
              except Exception as e:
                  message = exception_message(e)
                  raise ValueError(encoder.JSONEncoder().encode(message))

          # Polling functionality for async CUD operations

          def poll(event):
              log_group = os.getenv("AWS_LAMBDA_LOG_GROUP_NAME")
              cluster_name = event["ResourceProperties"].get("ClusterName")
              try:
                  cluster = pc.describe_cluster(cluster_name=cluster_name)
                  status = cluster.get("clusterStatus")

                  if status in {"CREATE_COMPLETE", "UPDATE_COMPLETE"}:
                      update_response(cluster)
                      return cluster_name
                  elif status in {"CREATE_FAILED", "UPDATE_FAILED", "DELETE_FAILED"}:
                      reasons = ",".join(f["failureCode"] for f in cluster.get("failures", []))
                      raise ValueError(f"{cluster_name}: {reasons} (LogGroup: {log_group})")

              # If create fails and we try to roll-back (e.g. delete),
              # gracefully handle missing cluster. on the delete pathway, the
              # only invalid parameter can be the name
              except (ParameterException, NotFoundException):
                  if event["RequestType"].upper() == "DELETE":
                      # Returning a value here signifies that the delete is completed and we can stop polling
                      # not returning a value here causes cfn resource helper to keep polling.
                      return cluster_name
                  raise ValueError(f"{cluster_name} failed {event['RequestType'].upper()}. See LogGroup: {log_group}")

          @helper.poll_create
          def poll_create(event, context):
              return poll(event)

          @helper.poll_update
          def poll_update(event, context):
              return poll(event)

          @helper.poll_delete
          def poll_delete(event, context):
              return poll(event)

          def handler(event, context):
              try:
                  logger.info("Beginning of Pcluster custom resource Lambda function. Printing full event...")
                  logger.info(event)
                  if event["ResourceProperties"].get("ClusterConfiguration") or (event.get("OldResourceProperties") and event["OldResourceProperties"].get("ClusterConfiguration")):
                      boto3.client('s3').put_object(
                          Body=json.dumps(event),
                          Bucket="${PclusterCustomResourceBucket}",
                          Key=event["ResourceProperties"].get("ClusterName")+"/event.json"
                      )
                      event["ResourceProperties"].pop("ClusterConfiguration", None)
                      event.get("OldResourceProperties", {}).pop("ClusterConfiguration", None)
              except Exception as exception:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, event.get('PhysicalResourceId', 'PclusterClusterCustomResource'), str(exception))

              helper(event, context)


  ######### cluster
  PclusterCluster:
    Type: Custom::PclusterCluster
    Properties:
      ServiceToken: !GetAtt PclusterCfnFunction.Arn
      ClusterName: !Ref ClusterName
      ClusterConfiguration:
        Image:
          Os: ubuntu2004
          CustomAmi: !Ref CustomAmiId
        HeadNode:
          InstanceType: !Ref HeadNodeInstanceType
          Networking:
            SubnetId: !Ref FirstAZPrivateSubnetId
            ElasticIp: false
            SecurityGroups:
            - !Ref DatabaseClientSecGroup
            - !Ref HeadNodeSecGroup
            - !Ref VizBackendSecGroup
          Ssh:
            KeyName: !Ref KeyName
          LocalStorage:
            RootVolume:
              Size: !Ref HeadNodeRootVolumeSize
              Encrypted: !Ref HeadNodeRootVolumeEncrypted
              VolumeType: !Ref HeadNodeRootVolumeType
              DeleteOnTermination: true
            EphemeralVolume:
              MountDir: /scratch
          CustomActions:
            OnNodeConfigured:
              Script: !Ref ScriptUrl
          Iam:
            AdditionalIamPolicies:
              - Policy: !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
        DirectoryService:
          DomainName: !Ref ADDomain
          DomainAddr: !Ref ADAddr
          PasswordSecretArn: !Ref ADPasswordSecretArn
          DomainReadOnlyUser: !Ref ADReadonlyUser
          LdapTlsReqCert: never
          AdditionalSssdConfigs:
            ldap_auth_disable_tls_never_use_in_production: True

        SharedStorage:
        - MountDir: /nfs
          Name: projects
          StorageType: Efs
          EfsSettings:
            FileSystemId: !Ref EFSFileSystemId
        Scheduling:
          Scheduler: slurm
          SlurmSettings:
            QueueUpdateStrategy: TERMINATE
            Database:
              Uri: !Ref DatabaseUri
              UserName: !Ref DatabaseAdmin
              PasswordSecretArn: !Ref DatabasePasswordSecretArn

          SlurmQueues:
          - Name: master
            Networking:
              SubnetIds: !Ref ComputeNodeSubnets
              SecurityGroups:
              - !Ref ComputeNodeSecGroup
              - !Ref DatabaseClientSecGroup
              - !Ref VizBackendSecGroup
            ComputeResources:
            - Name: "cpu"
              Instances:
                 - InstanceType: t2.medium
              MinCount: 0
              MaxCount: 100
          - Name: cpu-spot
            CapacityType: SPOT
            AllocationStrategy: lowest-price
            Networking:
              SubnetIds: !Ref ComputeNodeSubnets
              SecurityGroups:
              - !Ref ComputeNodeSecGroup
              - !Ref DatabaseClientSecGroup
              - !Ref VizBackendSecGroup
            ComputeSettings:
              LocalStorage:
                RootVolume:
                  Size: !Ref ComputeNodeRootVolumeSize
                  Encrypted: !Ref ComputeNodeRootVolumeEncrypted
                  VolumeType: !Ref ComputeNodeRootVolumeType
                EphemeralVolume:
                  MountDir: /scratch
            ComputeResources:
            - Name: "cpu"
              Instances:
                 - InstanceType: !Ref CpuQueueNodeType
              MinCount: 0
              MaxCount: !Ref CpuQueueNodesMax
          - Name: cpu
            CapacityType: ONDEMAND
            Networking:
              SubnetIds: !Ref ComputeNodeSubnets
              SecurityGroups:
                - !Ref ComputeNodeSecGroup
                - !Ref DatabaseClientSecGroup
                - !Ref VizBackendSecGroup
            ComputeResources:
              - Name: "cpu"
                Instances:
                  - InstanceType: !Ref CpuQueueNodeType
                MinCount: 0
                MaxCount: !Ref CpuQueueNodesMax

          - Name: lightgpu-spot
            CapacityType: SPOT
            AllocationStrategy: lowest-price
            Networking:
              SubnetIds: !Ref ComputeNodeSubnets
              SecurityGroups:
              - !Ref ComputeNodeSecGroup
              - !Ref DatabaseClientSecGroup
              - !Ref VizBackendSecGroup
            ComputeSettings:
              LocalStorage:
                RootVolume:
                  Size: !Ref ComputeNodeRootVolumeSize
                  Encrypted: !Ref ComputeNodeRootVolumeEncrypted
                  VolumeType: !Ref ComputeNodeRootVolumeType
                EphemeralVolume:
                  MountDir: /scratch
            ComputeResources:
            - Name: "gpu"
              Instances:
                - InstanceType: !Ref LightGpuQueueNodeType
              MinCount: 0
              MaxCount: !Ref LightGpuQueueNodesMax
          - Name: lightgpu
            CapacityType: ONDEMAND
            Networking:
              SubnetIds: !Ref ComputeNodeSubnets
              SecurityGroups:
                - !Ref ComputeNodeSecGroup
                - !Ref DatabaseClientSecGroup
                - !Ref VizBackendSecGroup
            ComputeResources:
              - Name: "gpu"
                Instances:
                  - InstanceType: !Ref LightGpuQueueNodeType
                MinCount: 0
                MaxCount: !Ref LightGpuQueueNodesMax

          - Name: "project-spot"
            CapacityType: SPOT
            AllocationStrategy: lowest-price
            Networking:
              SubnetIds: !Ref ComputeNodeSubnets
              SecurityGroups:
              - !Ref ComputeNodeSecGroup
              - !Ref DatabaseClientSecGroup
              - !Ref VizBackendSecGroup
            ComputeSettings:
              LocalStorage:
                RootVolume:
                  Size: !Ref ComputeNodeRootVolumeSize
                  Encrypted: !Ref ComputeNodeRootVolumeEncrypted
                  VolumeType: !Ref ComputeNodeRootVolumeType
                EphemeralVolume:
                  MountDir: /scratch
            ComputeResources:
            - Name: "cpu"
              Instances:
                - InstanceType: !Ref ProjectQueueCpuNodeType
              MinCount: 0
              MaxCount: !Ref ProjectQueueCpuNodesMax
            - Name: "gpu"
              Instances:
                - InstanceType: !Ref ProjectQueueGpuNodeType
              MinCount: 0
              MaxCount: !Ref ProjectQueueGpuNodesMax
          - Name: "project"
            CapacityType: ONDEMAND
            Networking:
              SubnetIds: !Ref ComputeNodeSubnets
              SecurityGroups:
              - !Ref ComputeNodeSecGroup
              - !Ref DatabaseClientSecGroup
              - !Ref VizBackendSecGroup
            ComputeSettings:
              LocalStorage:
                RootVolume:
                  Size: !Ref ComputeNodeRootVolumeSize
                  Encrypted: !Ref ComputeNodeRootVolumeEncrypted
                  VolumeType: !Ref ComputeNodeRootVolumeType
                EphemeralVolume:
                  MountDir: /scratch
            ComputeResources:
            - Name: "cpu"
              Instances:
                - InstanceType: !Ref ProjectQueueCpuNodeType
              MinCount: 0
              MaxCount: !Ref ProjectQueueCpuNodesMax
            - Name: "gpu"
              Instances:
                - InstanceType: !Ref ProjectQueueGpuNodeType
              MinCount: 0
              MaxCount: !Ref ProjectQueueGpuNodesMax

            # Image:
            #   CustomAmi: !Ref CustomAmiId


          - Name: "debug"
            CapacityType: SPOT
            AllocationStrategy: lowest-price
            Networking:
              SubnetIds: !Ref ComputeNodeSubnets
              SecurityGroups:
              - !Ref ComputeNodeSecGroup
              - !Ref DatabaseClientSecGroup
              - !Ref VizBackendSecGroup
            ComputeSettings:
              LocalStorage:
                RootVolume:
                  Size: !Ref ComputeNodeRootVolumeSize
                  Encrypted: !Ref ComputeNodeRootVolumeEncrypted
                  VolumeType: !Ref ComputeNodeRootVolumeType
                EphemeralVolume:
                  MountDir: /scratch
            ComputeResources:
            - Name: "cpu"
              Instances:
                 - InstanceType: !Ref DebugQueueCPUNodeType
              MinCount: 0
              MaxCount: !Ref DebugQueueCPUNodesMax
              #SpotPrice: !Ref AWS::NoValue
            - Name: "gpu"
              Instances:
                - InstanceType: !Ref DebugQueueGPUNodeType
              MinCount: 0
              MaxCount: !Ref DebugQueueGPUNodeMax
              #SpotPrice: !Ref AWS::NoValue

            # Image:
            #   CustomAmi: !Ref CustomAmiId


Outputs:
  ParallelClusterLogRetrievalPolicy:
    Value: !Ref ParallelClusterLogRetrievalPolicy

  ParallelClusterDescribeImageManagedPolicy:
    Value: !Ref ParallelClusterDescribeImageManagedPolicy

  ParallelClusterListImagesManagedPolicy:
    Value: !Ref ParallelClusterListImagesManagedPolicy

  ParallelClusterClusterPolicy:
    Value: !Ref ParallelClusterClusterPolicy

  ParallelClusterLambdaRoleArn:
    Value: !GetAtt ParallelClusterLambdaRole.Arn

  DefaultParallelClusterIamAdminPolicy:
    Value: !Ref DefaultParallelClusterIamAdminPolicy

  PclusterCustomResourceBucket:
    Value: !Ref PclusterCustomResourceBucket
